<!--{
	"Title": "编写 Web 应用程序",
	"Template": true
}-->

<h2>介绍</h2>

<p>
    本教程涵盖：
</p>
<ul>
    <li>使用加载和保存方法创建数据结构</li>
    <li>使用 <code>net/http</code> 包构建 Web 应用程序
    <li>使用 <code>html/template</code> 包用于处理 HTML 模板</li>
    <li>使用 <code>regexp</code> 包用于验证用户输入</li>
    <li>使用闭包</li>
</ul>

<p>
    假设知识：
</p>
<ul>
    <li>编程经验</li>
    <li>了解基本的网络技术（HTTP、HTML）</li>
    <li>一些UNIX/DOS命令行知识</li>
</ul>

<h2>入门</h2>

<p>
    目前，你需要有 FreeBSD、Linux、macOS 或 Windows 机器才能运行 Go。我们将使用 <code>$</code> 来表示命令提示符。
</p>

<p>
    安装Go (见 <a href="/doc/install">安装说明</a>).
</p>

<p>
    在你的 <code>GOPATH</code> 中为本教程创建一个新目录，然后 cd 到它：
</p>

<pre>
$ mkdir gowiki
$ cd gowiki
</pre>

<p>
    创建一个名为 <code>wiki.go</code> 的文件，在你喜欢的编辑器中打开它，并添加以下几行：
</p>

<pre>
package main

import (
	"fmt"
	"os"
)
</pre>

<p>
    我们从 Go 标准库中导入 <code>fmt</code> 和 <code>os</code> 包。稍后，随着我们实现附加功能，我们将向这个 <code>import</code> 声明添加更多包。
</p>

<h2>数据结构</h2>

<p>
    让我们从定义数据结构开始。 wiki 由一系列相互关联的页面组成，每个页面都有一个标题和一个正文（页面内容）。在这里，我们将 <code>Page</code> 定义为具有两个字段的结构体，分别代表标题和正文。
</p>

{{code "part1.go" `/^type Page/` `/}/`}}

<p>
    <code>[]byte</code> 类型的意思是“一个 <code>byte</code> 切片”。 （有关切片的更多信息，请参阅<a
        href="/doc/articles/slices_usage_and_internals.html">切片：用法和内部结构</a>。）
    <code>Body</code> 元素是一个 <code>[]byte</code> 而不是 <code>string</code> 因为这是我们将使用的 <code>io</code> 库所期望的类型，如你会在下面看到。
</p>

<p>
    <code>Page</code> 结构描述了页面数据将如何存储在内存中。
    但是持久存储呢？我们可以通过在 <code>Page</code> 上创建一个 <code>save</code> 方法来解决这个问题：
</p>

{{code "part1.go" `/^func.*Page.*save/` `/}/`}}

<p>
    这个方法的签名是：“这是一个名为 <code>save</code> 的方法，它接受 <code>p</code>，一个指向 <code>Page</code> 的指针。它没有参数，并返回一个<code>error</code>
    类型的值。”
</p>

<p>
    此方法会将 <code>Page</code> 的 <code>Body</code> 保存到文本文件中。为简单起见，我们将使用 <code>Title</code> 作为文件名。
</p>

<p>
    <code>save</code> 方法返回一个 <code>error</code> 值，因为这是 <code>WriteFile</code>（将字节切片写入文件的标准库函数）的返回类型。 <code>save</code>
    方法返回错误值，让应用程序处理它，如果在写入文件时出现任何问题。如果一切顺利，<code>Page.save()</code> 将返回 <code>nil</code>（指针、接口和其他一些类型的零值）。
</p>

<p>
    八进制整数文字 <code>0600</code>，作为第三个参数传递给 <code>WriteFile</code>，表示该文件应该只为当前用户创建具有读写权限。 （有关详细信息，请参阅 Unix 手册页 <code>open(2)</code>。）
</p>

<p>
    除了保存页面，我们还需要加载页面：
</p>

{{code "part1-noerror.go" `/^func loadPage/` `/^}/`}}

<p>
    函数 <code>loadPage</code> 根据 title 参数构造文件名，将文件内容读入一个新变量 <code>body</code>，并返回一个指向 <code>Page</code> 字面量的指针正确的标题和正文值。
</p>

<p>
    函数可以返回多个值。标准库函数 <code>os.ReadFile</code> 返回 <code>[]byte</code> 和 <code>error</code>。在 <code>loadPage</code>
    中，错误尚未处理；下划线（<code>_</code>）符号表示的“空白标识符”用于丢弃错误返回值（本质上是将值赋值为空）。
</p>

<p>
    但是如果 <code>ReadFile</code> 遇到错误会发生什么？例如，该文件可能不存在。我们不应忽视此类错误。让我们修改函数以返回 <code>Page</code> 和 <code>error</code>。
</p>

{{code "part1.go" `/^func loadPage/` `/^}/`}}

<p>
    此函数的调用者现在可以检查第二个参数；如果它是 <code>nil</code> 那么它已经成功加载了一个页面。如果不是，它将是一个可由调用者处理的 <code>error</code>（有关详细信息，请参阅<a
        href="/ref/spec#Errors">语言规范</a>）。
</p>

<p>
    在这一点上，我们有一个简单的数据结构和保存到文件和从文件加载的能力。让我们编写一个 <code>main</code> 函数来测试我们编写的内容：
</p>

{{code "part1.go" `/^func main/` `/^}/`}}

<p>
    编译并执行此代码后，将创建一个名为 <code>TestPage.txt</code> 的文件，其中包含 <code>p1</code> 的内容。然后该文件将被读入结构 <code>p2</code>，并将其 <code>Body</code> 元素打印到屏幕上。
</p>

<p>
    您可以像这样编译和运行程序：
</p>

<pre>
$ go build wiki.go
$ ./wiki
This is a sample Page.
</pre>

<p>
    （如果您使用的是 Windows，则必须键入“<code>wiki</code>”而不带“<code>./</code>”才能运行该程序。）
</p>

<p>
    <a href="part1.go">单击此处查看我们迄今为止编写的代码。</a>
</p>

<h2>介绍 <code>net/http</code> 包（插曲）</h2>

<p>
    这是一个简单的 Web 服务器的完整工作示例：
</p>

{{code "http-sample.go"}}

<p>
    <code>main</code> 函数以对 <code>http.HandleFunc</code> 的调用开始，它告诉 <code>http</code> 包处理对 Web 根 (<code>"/"</code>) 和 <code>handler</code>。
</p>

<p>
    然后它调用 <code>http.ListenAndServe</code>，指定它应该在任何接口 (<code>":8080"</code>) 上侦听端口 8080。 （暂时不要担心它的第二个参数 <code>nil</code>。）该函数将一直阻塞，直到程序终止。
</p>

<p>
    <code>ListenAndServe</code> 总是返回错误，因为它只在发生意外错误时返回。为了记录该错误，我们用 <code>log.Fatal</code> 包装函数调用。
</p>

<p>
    函数 <code>handler</code> 的类型是 <code>http.HandlerFunc</code>。它需要一个 <code>http.ResponseWriter</code> 和一个 <code>http.Request</code> 作为它的参数。
</p>

<p>
    <code>http.ResponseWriter</code> 值组合了 HTTP 服务器的响应；通过写入它，我们将数据发送到 HTTP 客户端。
</p>

<p>
    <code>http.Request</code> 是表示客户端 HTTP 请求的数据结构。 <code>r.URL.Path</code> 是请求 URL 的路径组件。尾随 <code>[1:]</code> 表示“创建 <code>Path</code> 从第一个字符到结尾的子切片。”这会从路径名中删除前导“”。
</p>

<p>
    如果您运行此程序并访问 URL：
</p>
<pre>http://localhost:8080/monkeys</pre>
<p>
    该程序将显示一个页面，其中包含：
</p>
<pre>Hi there, I love monkeys!</pre>

<h2>使用 <code>net/http</code> 来提供 wiki 页面</h2>

<p>
    要使用 <code>net/http</code> 包，必须导入它：
</p>

<pre>
import (
	"fmt"
	"os"
	"log"
	<b>"net/http"</b>
)
</pre>

<p>
    让我们创建一个处理程序，<code>viewHandler</code>，它将允许用户查看 wiki 页面。它将处理以“/view/”为前缀的 URL。
</p>

{{code "part2.go" `/^func viewHandler/` `/^}/`}}

<p>
    再次注意使用 <code>_</code> 来忽略 <code>loadPage</code> 的 <code>error</code> 返回值。这样做是为了简单起见，通常被认为是不好的做法。我们稍后会处理这个问题。
</p>

<p>
    首先，该函数从请求 URL 的路径组件 <code>r.URL.Path</code> 中提取页面标题。
    <code>Path</code> 使用 <code>[len("view"):]</code> 重新切片以删除请求路径的前导 <code>"view"</code> 组件。
    这是因为路径总是以 <code>"view"</code> 开头，它不是页面标题的一部分。
</p>

<p>
    然后该函数加载页面数据，使用简单的 HTML 字符串格式化页面，并将其写入 <code>w</code>，<code>http.ResponseWriter</code>。
</p>

<p>
    为了使用这个处理程序，我们重写我们的 <code>main</code> 函数来初始化 <code>http</code> 使用 <code>viewHandler</code> 来处理路径 <code>view</code> 下的任何请求。
</p>

{{code "part2.go" `/^func main/` `/^}/`}}

<p>
    <a href="part2.go">单击此处查看我们迄今为止编写的代码。</a>
</p>

<p>
    让我们创建一些页面数据（如 <code>test.txt</code>），编译我们的代码，并尝试提供一个 wiki 页面。
</p>

<p>
    在编辑器中打开 <code>test.txt</code> 文件，并在其中保存字符串“Hello world”（不带引号）。
</p>

<pre>
$ go build wiki.go
$ ./wiki
</pre>

<p>
    （如果您使用的是 Windows，则必须键入“<code>wiki</code>”而不带“<code>./</code>”才能运行该程序。）
</p>

<p>
    运行此 Web 服务器后，访问 <code><a
        href="http://localhost:8080/view/test">http://localhost:8080/view/test</a></code>
    应该显示一个标题为“test”的页面，其中包含“Hello world”。
</p>

<h2>编辑页面</h2>

<p>
    维基不是没有编辑页面能力的维基。让我们创建两个新的处理程序：一个名为 <code>editHandler</code> 以显示“编辑页面”表单，另一个名为 <code>saveHandler</code> 以保存通过表单输入的数据。
</p>

<p>
    首先，我们将它们添加到 <code>main()</code> 中：
</p>

{{code "final-noclosure.go" `/^func main/` `/^}/`}}

<p>
    函数 <code>editHandler</code> 加载页面（或者，如果它不存在，则创建一个空的 <code>Page</code> 结构），并显示一个 HTML 表单。
</p>

{{code "notemplate.go" `/^func editHandler/` `/^}/`}}

<p>
    这个函数可以正常工作，但所有硬编码的 HTML 都很丑陋。当然，还有更好的方法。
</p>

<h2><code>html/template</code> 包</h2>

<p>
    <code>html/template</code> 包是 Go 标准库的一部分。我们可以使用 <code>html/template</code> 将 HTML 保存在单独的文件中，允许我们更改编辑页面的布局而无需修改底层 Go 代码。
</p>

<p>
    首先，我们必须将 <code>html/template</code> 添加到导入列表中。我们也不会再使用 <code>fmt</code>，所以我们必须删除它。
</p>

<pre>
import (
	<b>"html/template"</b>
	"os"
	"net/http"
)
</pre>

<p>
    让我们创建一个包含 HTML 表单的模板文件。
    打开一个名为 <code>edit.html</code> 的新文件，并添加以下几行：
</p>

{{code "edit.html"}}

<p>
    修改 <code>editHandler</code> 以使用模板，而不是硬编码的 HTML：
</p>

{{code "final-noerror.go" `/^func editHandler/` `/^}/`}}

<p>
    函数 <code>template.ParseFiles</code> 将读取 <code>edit.html</code> 的内容并返回一个 <code>template.Template</code>。
</p>

<p>
   方法 <code>t.Execute</code> 执行模板，将生成的 HTML 写入 <code>http.ResponseWriter</code>。 <code>.Title</code> 和 <code>.Body</code> 虚线标识符指的是 <code>p.Title</code> 和 <code>p.Body</code>。
</p>

<p>
    模板指令括在双花括号中。
    <code>printf "%s" .Body</code> 指令是一个函数调用，它输出 <code>.Body</code> 作为字符串而不是字节流，
    与调用 <code>fmt.Printf</code> 相同。
    <code>html/template</code> 包有助于确保模板操作仅生成安全且外观正确的 HTML。 例如，它会自动转义任何大于号 (<code>></code>)，将其替换为 <code>&gt;</code>，以确保用户数据不会破坏表单 HTML。
</p>

<p>
    由于我们现在正在使用模板，让我们为 <code>viewHandler</code> 创建一个名为 <code>view.html</code> 的模板：
</p>

{{code "view.html"}}

<p>
    相应地修改 <code>viewHandler</code>：
</p>

{{code "final-noerror.go" `/^func viewHandler/` `/^}/`}}

<p>
    请注意，我们在两个处理程序中使用了几乎完全相同的模板代码。让我们通过将模板代码移动到它自己的函数来消除这种重复：
</p>

{{code "final-template.go" `/^func renderTemplate/` `/^}/`}}

<p>
    并修改处理程序以使用该函数：
</p>

{{code "final-template.go" `/^func viewHandler/` `/^}/`}}
{{code "final-template.go" `/^func editHandler/` `/^}/`}}

<p>
    如果我们在 <code>main</code> 中注释掉我们未实现的保存处理程序的注册，我们可以再次构建和测试我们的程序。
    <a href="part3.go">单击此处查看我们迄今为止编写的代码。</a>
</p>

<h2>处理不存在的页面</h2>

<p>
    如果您访问 <a href="http://localhost:8080/view/APageThatDoesntExist">
    <code>/view/APageThatDoesntExist</code></a>怎么办? 您将看到一个包含 HTML 的页面。这是因为它忽略了来自 <code>loadPage</code> 的错误返回值，并继续尝试填充没有数据的模板。 相反，如果请求的页面不存在，它应该将客户端重定向到编辑页面，以便可以创建内容：
</p>

{{code "part3-errorhandling.go" `/^func viewHandler/` `/^}/`}}

<p>
    <code>http.Redirect</code> 函数将 <code>http.StatusFound</code> (302) 的 HTTP 状态代码和 <code>Location</code> 标头添加到 HTTP 响应中。
</p>

<h2>保存页面</h2>

<p>
    函数 <code>saveHandler</code> 将处理位于编辑页面上的表单的提交。取消注释 <code>main</code> 中的相关行后，让我们实现处理程序：
</p>

{{code "final-template.go" `/^func saveHandler/` `/^}/`}}

<p>
    页面标题（在 URL 中提供）和表单的唯一字段，
    <code>Body</code>，存储在一个新的 <code>Page</code> 中。
    然后调用 <code>save()</code> 方法将数据写入文件，客户端被重定向到 <code>/view/</code> 页面。
</p>

<p>
    <code>FormValue</code> 返回的值属于 <code>string</code> 类型。我们必须将该值转换为 <code>[]byte</code> 才能适合 <code>Page</code> 结构。我们使用 <code>[]byte(body)</code> 来执行转换。
</p>

<h2>错误处理</h2>

<p>
    在我们的程序中有几个地方忽略了错误。这是不好的做法，尤其是因为当发生错误时，程序会出现意外行为。更好的解决方案是处理错误并向用户返回错误消息。这样，如果出现问题，服务器将按照我们想要的方式运行，并且可以通知用户。
</p>

<p>
    首先，让我们处理<code>renderTemplate</code>中的错误：
</p>

{{code "final-parsetemplate.go" `/^func renderTemplate/` `/^}/`}}

<p>
    <code>http.Error</code> 函数发送指定的 HTTP 响应代码（在本例中为“内部服务器错误”）和错误消息。
    把它放在一个单独的函数中的决定已经得到了回报。
</p>

<p>
    现在让我们修复 <code>saveHandler</code>：
</p>

{{code "part3-errorhandling.go" `/^func saveHandler/` `/^}/`}}

<p>
    <code>p.save()</code> 期间发生的任何错误都会报告给用户。
</p>

<h2>模板缓存</h2>

<p>
    这段代码效率低下：每次渲染页面时，<code>renderTemplate</code> 都会调用 <code>ParseFiles</code>。
    更好的方法是在程序初始化时调用一次 <code>ParseFiles</code>，将所有模板解析为一个 <code>*Template</code>。
    然后我们可以使用
    <a href="/pkg/html/template/#Template.ExecuteTemplate"><code>ExecuteTemplate</code></a>
    渲染特定模板的方法。
</p>

<p>
    首先，我们创建一个名为 <code>templates</code> 的全局变量，并使用 <code>ParseFiles</code> 对其进行初始化。
</p>

{{code "final.go" `/var templates/`}}

<p>
    函数 <code>template.Must</code> 是一个方便的包装器，当传递一个非 nil <code>error</code> 值时会发生恐慌，否则返回 <code>Template</code> 不变。恐慌在这里是合适的；如果无法加载模板，唯一明智的做法就是退出程序。
</p>

<p>
    <code>ParseFiles</code> 函数采用任意数量的字符串参数来标识我们的模板文件，并将这些文件解析为以基本文件名命名的模板。如果我们要向我们的程序添加更多模板，我们会将它们的名称添加到 <code>ParseFiles</code> 调用的参数中。
</p>

<p>
    然后我们修改 <code>renderTemplate</code> 函数以使用适当模板的名称调用 <code>templates.ExecuteTemplate</code> 方法：
</p>

{{code "final.go" `/func renderTemplate/` `/^}/`}}

<p>
    请注意，模板名称是模板文件名，因此我们必须将 <code>".html"</code> 附加到 <code>tmpl</code> 参数。
</p>

<h2>验证</h2>

<p>
    正如您可能已经观察到的，这个程序有一个严重的安全漏洞：用户可以提供任意路径在服务器上进行读写。为了缓解这种情况，我们可以编写一个函数来使用正则表达式验证标题。
</p>

<p>
    首先，将 <code>"regex"</code> 添加到 <code>import</code> 列表。然后我们可以创建一个全局变量来存储您的验证表达式：
</p>

{{code "final-noclosure.go" `/^var validPath/`}}

<p>
    函数 <code>regexp.MustCompile</code> 将解析和编译正则表达式，并返回一个 <code>regexp.Regexp</code>。
    <code>MustCompile</code> 与 <code>Compile</code> 的不同之处在于，如果表达式编译失败，它会崩溃，而 <code>Compile</code> 返回一个 <code>error</code> 作为第二个参数。
</p>

<p>
    现在，让我们编写一个函数，使用 <code>validPath</code> 表达式来验证路径并提取页面标题：
</p>

{{code "final-noclosure.go" `/func getTitle/` `/^}/`}}

<p>
    如果标题有效，它将与 <code>nil</code> 错误值一起返回。如果标题无效，该函数将向 HTTP 连接写入“404 Not Found”错误，并向处理程序返回错误。要创建新错误，我们必须导入 <code>errors</code> 包。
</p>

<p>
    让我们在每个处理程序中调用 <code>getTitle</code> ：
</p>

{{code "final-noclosure.go" `/^func viewHandler/` `/^}/`}}
{{code "final-noclosure.go" `/^func editHandler/` `/^}/`}}
{{code "final-noclosure.go" `/^func saveHandler/` `/^}/`}}

<h2>介绍函数字面量和闭包</h2>

<p>
    在每个处理程序中捕获错误条件会引入大量重复代码。
    如果我们可以将每个处理程序包装在一个执行此验证和错误检查的函数中会怎样？ Go的
    <a href="/ref/spec#Function_literals">function
        literals</a> 提供一种强大的抽象功能方法，可以帮助我们在这里。
</p>

<p>
    首先，我们重写每个处理程序的函数定义以接受标题字符串：
</p>

<pre>
func viewHandler(w http.ResponseWriter, r *http.Request, title string)
func editHandler(w http.ResponseWriter, r *http.Request, title string)
func saveHandler(w http.ResponseWriter, r *http.Request, title string)
</pre>

<p>
    现在让我们定义一个包装函数 <i>采用上述类型的函数</i>, 并返回一个 <code>http.HandlerFunc</code> 类型的函数（适合传递给函数 <code>http.HandleFunc</code>）：
</p>

<pre>
func makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Here we will extract the page title from the Request,
		// and call the provided handler 'fn'
	}
}
</pre>

<p>
    返回的函数称为闭包，因为它包含在其外部定义的值。在这种情况下，变量 <code>fn</code>（<code>makeHandler</code> 的单个参数）被闭包括起来。变量 <code>fn</code> 将是我们的保存、编辑或查看处理程序之一。
</p>

<p>
    现在我们可以从 <code>getTitle</code> 中获取代码并在这里使用它（稍作修改）：
</p>

{{code "final.go" `/func makeHandler/` `/^}/`}}

<p>
    <code>makeHandler</code> 返回的闭包是一个函数，它接受一个 <code>http.ResponseWriter</code> 和 <code>http.Request</code>（换句话说，一个 <code>http.HandlerFunc</code> >)。
    闭包从请求路径中提取 <code>title</code>，并使用 <code>validPath</code> 正则表达式对其进行验证。如果 <code>title</code> 无效，则会使用 <code>http.NotFound</code> 函数将错误写入 <code>ResponseWriter</code>。
    如果 <code>title</code> 有效，封闭的处理函数<code>fn</code> 则将使用 <code>ResponseWriter</code>、<code>Request</code> 和  <code>title</code> 作为参数。
</p>

<p>
    现在我们可以在 <code>main</code> 中使用 <code>makeHandler</code> 包装处理程序函数，然后将它们注册到 <code>http</code> 包中：
</p>

{{code "final.go" `/func main/` `/^}/`}}

<p>
    最后，我们从处理程序函数中删除了对 <code>getTitle</code> 的调用，使它们更简单：
</p>

{{code "final.go" `/^func viewHandler/` `/^}/`}}
{{code "final.go" `/^func editHandler/` `/^}/`}}
{{code "final.go" `/^func saveHandler/` `/^}/`}}

<h2>试试看！</h2>

<p>
    <a href="final.go">单击此处查看最终代码清单。</a>
</p>

<p>
    重新编译代码，然后运行应用程序：
</p>

<pre>
$ go build wiki.go
$ ./wiki
</pre>

<p>
    访问 <a href="http://localhost:8080/view/ANewPage">http://localhost:8080/view/ANewPage</a>
    应该向您显示页面编辑表单。然后您应该能够输入一些文本，单击“保存”，然后重定向到新创建的页面。
</p>

<h2>其他任务</h2>

<p>
    以下是您可能想要自己解决的一些简单任务：
</p>

<ul>
    <li>将模板存储在 <code>tmpl</code> 中，将页面数据存储在 <code>data/</code> 中。
    <li>添加处理程序以使 Web 根重定向到 <code>/view/FrontPage</code>。
    </li>
    <li>通过使页面模板成为有效的 HTML 并添加一些 CSS 规则来修饰页面模板。
    </li>
    <li>通过将 <code>[PageName]</code> 的实例转换为 <br>
        <code> <a href="/view/PageName"> PageName  </a> </code> 来实现页面间链接。
        (提示：你可以使用 <code>regexp.ReplaceAllFunc</code> 来做到这一点)
    </li>
</ul>
